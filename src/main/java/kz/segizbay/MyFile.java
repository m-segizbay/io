package kz.segizbay;

import java.io.*;
import java.nio.file.*;
import java.nio.file.attribute.*;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.regex.*;
import java.util.stream.Collectors;

public class MyFile {
    // выводит список всех файлов и директорий для `path`
    public static void listDirectory(String path) {
        try {
            Files.list(Paths.get(path))
                    .map(Path::getFileName)
                    .map(Path::toString)
                    .forEach(System.out::println);
        } catch (IOException e) {
            System.out.println("Ошибка: " + e.getMessage());
        }
    }

    // выводит список файлов с расширением `.py` в `path`
    public static void listPythonFiles(String path) {
        try {
            Files.list(Paths.get(path))
                    .filter(p -> p.toString().endsWith(".py"))
                    .map(Path::getFileName)
                    .map(Path::toString)
                    .forEach(System.out::println);
        } catch (IOException e) {
            System.out.println("Ошибка: " + e.getMessage());
        }
    }

    // выводит `true`, если `path` это директория, в других случаях `false`
    public static void isDirectory(String path) {
        System.out.println(Files.isDirectory(Paths.get(path)));
    }

    // выводит `директория` или `файл` в зависимости от типа `path`
    public static void define(String path) {
        if (Files.isDirectory(Paths.get(path))) {
            System.out.println("директория");
        } else if (Files.isRegularFile(Paths.get(path))) {
            System.out.println("файл");
        } else {
            System.out.println("неизвестный тип");
        }
    }

    // выводит права для файла в формате `rwx` для текущего пользователя
    public static void printPermissions(String path) {
        try {
            PosixFilePermissions permissions = Files.getPosixFilePermissions(Paths.get(path));
            String result = permissions.stream()
                    .map(p -> p.toString().charAt(1))
                    .collect(StringBuilder::new, StringBuilder::append, StringBuilder::append)
                    .toString();
            System.out.println(result);
        } catch (IOException e) {
            System.out.println("Ошибка: " + e.getMessage());
        }
    }

    // устанавливает права для файла `path`
    public static void setPermissions(String path, String permissions) {
        try {
            Set<PosixFilePermission> perms = new HashSet<>();
            if (permissions.charAt(0) == 'r') perms.add(PosixFilePermission.OWNER_READ);
            if (permissions.charAt(1) == 'w') perms.add(PosixFilePermission.OWNER_WRITE);
            if (permissions.charAt(2) == 'x') perms.add(PosixFilePermission.OWNER_EXECUTE);
            if (permissions.charAt(3) == 'r') perms.add(PosixFilePermission.GROUP_READ);
            if (permissions.charAt(4) == 'w') perms.add(PosixFilePermission.GROUP_WRITE);
            if (permissions.charAt(5) == 'x') perms.add(PosixFilePermission.GROUP_EXECUTE);
            if (permissions.charAt(6) == 'r') perms.add(PosixFilePermission.OTHERS_READ);
            if (permissions.charAt(7) == 'w') perms.add(PosixFilePermission.OTHERS_WRITE);
            if (permissions.charAt(8) == 'x') perms.add(PosixFilePermission.OTHERS_EXECUTE);

            Files.setPosixFilePermissions(Paths.get(path), perms);
        } catch (IOException e) {
            System.out.println("Ошибка: " + e.getMessage());
        }
    }

    // выводит контент файла
    public static void printContent(String path) {
        try {
            Files.lines(Paths.get(path)).forEach(System.out::println);
        } catch (IOException e) {
            System.out.println("Ошибка: " + e.getMessage());
        }
    }

    // добавляет строку `# Autogenerated line` в конец `path`
    public static void appendFooter(String path) {
        try {
            Files.write(Paths.get(path), "# Autogenerated line\n".getBytes(), StandardOpenOption.APPEND);
        } catch (IOException e) {
            System.out.println("Ошибка: " + e.getMessage());
        }
    }

    // создает копию `path` в директорию `/tmp/${date}.backup`
    public static void createBackup(String path) {
        try {
            String date = new SimpleDateFormat("dd-MM-yyyy").format(new Date());
            Path source = Paths.get(path);
            Path destination = Paths.get("/tmp/" + date + ".backup");

            if (Files.isDirectory(source)) {
                Files.walk(source)
                        .forEach(sourcePath -> {
                            try {
                                Path destPath = destination.resolve(source.relativize(sourcePath));
                                if (Files.isDirectory(sourcePath)) {
                                    Files.createDirectories(destPath);
                                } else {
                                    Files.copy(sourcePath, destPath, StandardCopyOption.REPLACE_EXISTING);
                                }
                            } catch (IOException e) {
                                System.out.println("Ошибка: " + e.getMessage());
                            }
                        });
            } else {
                Files.copy(source, destination.resolve(source.getFileName()), StandardCopyOption.REPLACE_EXISTING);
            }
        } catch (IOException e) {
            System.out.println("Ошибка: " + e.getMessage());
        }
    }

    // выводит самое длинное слово в файле
    public static void printLongestWord(String path) {
        try {
            Optional<String> longestWord = Files.lines(Paths.get(path))
                    .flatMap(line -> Arrays.stream(line.split("\\W+")))
                    .max(Comparator.comparingInt(String::length));
            longestWord.ifPresent(System.out::println);
        } catch (IOException e) {
            System.out.println("Ошибка: " + e.getMessage());
        }
    }

    // выводит список команд и их описание
    public static void help() {
        System.out.println("ls <path>               выводит список всех файлов и директорий для `path`");
        System.out.println("ls_py <path>            выводит список файлов с расширением `.py` в `path`");
        System.out.println("is_dir <path>           выводит `true`, если `path` это директория, в других случаях `false`");
        System.out.println("define <path>           выводит `директория` или `файл` в зависимости от типа `path`");
        System.out.println("readmod <path>          выводит права для файла в формате `rwx` для текущего пользователя");
        System.out.println("setmod <path> <perm>    устанавливает права для файла `path`");
        System.out.println("cat <path>              выводит контент файла");
        System.out.println("append <path>           добавляет строку `# Autogenerated line` в конец `path`");
        System.out.println("bc <path>               создает копию `path` в директорию `/tmp/${date}.backup` где, date - это дата в формате `dd-mm-yyyy`");
        System.out.println("greplong <path>         выводит самое длинное слово в файле");
        System.out.println("help                    выводит список команд и их описание");
        System.out.println("exit                    завершает работу программы");
    }

    // завершает работу программы
    public static void exit() {
        System.out.println("Goodbye");
    }
}